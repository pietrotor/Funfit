scalar Date
scalar Time
scalar ObjectId
enum StatusEnum {
  OK
  ERROR
}

type Query {
  login(loginInput: LoginInput!): LoginResponse
  currentUser: UserResponse
  getRoles(paginationInput: PaginationInput!): RolesResponse
  getUsers(paginationInput: PaginationInput!): UsersResponse
  getUserById(id: ObjectId!): UserResponse
  getProducts(paginationInput: PaginationInput!): ProductsResponse
  getProductById(id: ObjectId!): ProductResponse
  getWarehouses(paginationInput: PaginationInput!): WarehousesResponse
}
type Mutation {
  createUser(userInput: UserInput!): UserResponse
  updateUser(
    updateUserInput: UpdateUserInput!
    deleteInput: Boolean = false
  ): UserResponse
  createProduct(createProductInput: CreateProductInput!): ProductResponse
  updateProduct(updateProductInput: UpdateProductInput!): ProductResponse
  deleteProduct(id: ObjectId!): ProductResponse
}
# TYPE ENTITIES ------------------------------------------------------------------------------------------------------------------------------------
type Role {
  id: ObjectId!
  name: String!
  code: String!
  status: Boolean!
}
type User {
  id: ObjectId!
  name: String!
  lastName: String!
  email: String!
  phone: String!
  lastLogin: Date
  status: Boolean!
  createdBy: ObjectId
  roleId: ObjectId!
  # resolvers
  roleInfo: Role
}
type Product {
  id: ObjectId!
  name: String!
  # TODO: Change to pricelist
  price: Float!
  code: String!
  units: String!
  description: String!
  cost: Float
  image: String
  warehouses: [ObjectId!]!
}
type Warehouse {
  id: ObjectId!
  name: String!
}
# RESPONSES -----------------------------------------------------------------------------------------------------------------------------------------
interface ResponseBase {
  errorInput: [ErrorInput!]
  status: StatusEnum!
  message: String
}
type ErrorInput {
  message: String!
  field: String
}
type Response implements ResponseBase {
  errorInput: [ErrorInput!]
  status: StatusEnum!
  message: String
}

type LoginResponse implements ResponseBase {
  errorInput: [ErrorInput!]
  status: StatusEnum!
  message: String
  token: String
}
type RolesResponse implements ResponseBase {
  errorInput: [ErrorInput!]
  status: StatusEnum!
  message: String
  data: [Role]
}
type UsersResponse implements ResponseBase {
  errorInput: [ErrorInput!]
  status: StatusEnum!
  message: String
  data: [User!]
  totalRecords: Int
  totalPages: Int
  rows: Int
  currentPage: Int
}
type UserResponse implements ResponseBase {
  errorInput: [ErrorInput!]
  status: StatusEnum!
  message: String
  data: User
}
type ProductsResponse implements ResponseBase {
  errorInput: [ErrorInput!]
  status: StatusEnum!
  message: String
  data: [Product!]
  totalRecords: Int
  totalPages: Int
  rows: Int
  currentPage: Int
}
type ProductResponse implements ResponseBase {
  errorInput: [ErrorInput!]
  status: StatusEnum!
  message: String
  data: Product
}
type WarehousesResponse implements ResponseBase {
  errorInput: [ErrorInput!]
  status: StatusEnum!
  message: String
  data: [Warehouse!]
  totalRecords: Int
  totalPages: Int
  rows: Int
  currentPage: Int
}
# INPUTS -----------------------------------------------------------------------------------------------------------------------------------------
input LoginInput {
  email: String!
  password: String!
}
input PaginationInput {
  rows: Int
  page: Int
  filter: String
}
input UserInput {
  name: String!
  lastName: String!
  email: String!
  password: String!
  phone: String!
  roleId: ObjectId!
}
input UpdateUserInput {
  id: ObjectId!
  name: String
  lastName: String
  email: String
  password: String
  phone: String
  roleId: ObjectId
  status: Boolean
}
input CreateProductInput {
  name: String!
  # TODO: Change to pricelist
  price: Float!
  units: String!
  description: String!
  cost: Float
  image: String
  warehouses: [ObjectId!]!
}
input UpdateProductInput {
  id: ObjectId!
  name: String
  # TODO: Change to pricelist
  price: Float
  units: String
  description: String
  cost: Float
  image: String
  warehouses: [ObjectId!]
}
